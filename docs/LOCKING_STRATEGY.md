# 🔒 데이터베이스 락(Lock) 전략 및 선정 이유

## 1. 락(Lock) 기법 비교

### 🔴 비관적 락 (Pessimistic Lock)
**"충돌이 발생할 것이라고 비관적으로 가정하고, 데이터를 조회할 때부터 문을 잠근다"**

*   **동작 방식**: 트랜잭션이 시작될 때 데이터에 락(Lock)을 걸어 다른 트랜잭션이 접근하지 못하게 막습니다. (주로 `SELECT ... FOR UPDATE` 구문 사용)
*   **장점**:
    *   **데이터 무결성 보장**: 동시성 문제가 원천 차단됩니다.
    *   충돌이 빈번한 환경에서 롤백 비용을 줄일 수 있습니다.
*   **단점**:
    *   **성능 저하**: 락을 획득할 때까지 대기해야 하므로 처리 속도가 느려질 수 있습니다.
    *   **데드락(Deadlock) 위험**: 서로 다른 자원을 점유하고 상대방을 기다리는 교착 상태에 빠질 수 있습니다.

### 🟢 낙관적 락 (Optimistic Lock)
**"충돌이 발생하지 않을 것이라고 낙관적으로 가정하고, 마지막에 검사한다"**

*   **동작 방식**: DB의 락 기능을 사용하지 않고, 애플리케이션 레벨에서 **버전(Version)** 컬럼을 이용해 관리합니다. 데이터를 수정할 때 내가 읽은 버전과 현재 버전이 같은지 확인합니다.
*   **장점**:
    *   **성능 우수**: DB 락을 걸지 않으므로 대기 시간이 없고 빠릅니다. (Lock-free)
    *   충돌이 드문 환경에서 매우 효율적입니다.
*   **단점**:
    *   **재시도 로직 필요**: 충돌 발생 시 예외가 터지며, 개발자가 직접 재시도(Retry) 로직을 구현해야 합니다.
    *   충돌이 잦으면 롤백과 재시도가 반복되어 오히려 성능이 떨어질 수 있습니다.

---

## 2. 우리 프로젝트의 선택: 비관적 락 (Pessimistic Lock)

현재 **예약 시스템(Reservation Service)** 에서는 **비관적 락(Pessimistic Lock)** 을 채택하여 사용하고 있습니다.

### 🛠 구현 코드
```java
// 1. 객실 정보를 조회할 때 쓰기 락(PESSIMISTIC_WRITE)을 획득하여 다른 트랜잭션 차단
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT r FROM Room r WHERE r.roomId = :id")
Optional<Room> findByIdWithLock(@Param("id") Long id);

// 2. 예약 인원을 조회할 때도 읽기 락(PESSIMISTIC_READ)을 걸어 데이터 변경 방지
@Lock(LockModeType.PESSIMISTIC_READ)
@Query("SELECT ... FROM Reservation ...")
Integer sumGuestCountByRoomIdAndDateRange(...);
```

---

## 3. 선정 이유 (Why?)

우리는 왜 낙관적 락 대신 성능이 떨어질 수 있는 **비관적 락**을 선택했을까요?

### ✅ 이유 1: 데이터 무결성이 최우선 (초과 예약 방지)
숙소 예약 시스템에서 가장 치명적인 오류는 **"오버부킹(Double Booking)"** 입니다.
*   **상황**: 정원이 1명 남은 방에 10명이 동시에 예약 시도.
*   **낙관적 락 실패 시**: 사용자들은 예약 프로세스를 다 밟고 마지막 "결제하기" 버튼을 눌렀을 때 "죄송합니다, 방금 매진되었습니다"라는 메시지를 보게 됩니다.
*   **비관적 락 사용 시**: 먼저 도착한 1명이 락을 걸고, 나머지는 잠시 대기하다가 "정원 초과" 메시지를 좀 더 빠르게, 확실하게 받거나 순차적으로 처리되어 정확한 정원 관리가 가능합니다.

### ✅ 이유 2: 재시도(Retry) 로직의 복잡성 회피
낙관적 락을 사용하면 충돌 시 `ObjectOptimisticLockingFailureException`이 발생합니다.
이 경우 시스템은 자동으로 **재시도**를 해야 하는데, 예약 시스템 특성상:
1.  사용자에게 다시 시도하라고 요청하거나,
2.  서버가 자동으로 n번 재시도해야 합니다.
이미 마감된 방에 대해 재시도를 계속하는 것은 자원 낭비이며, 사용자 경험에도 좋지 않습니다.

### ✅ 이유 3: 잦은 충돌이 예상되는 핫딜/성수기
인기 있는 숙소나 성수기에는 특정 객실에 트래픽이 몰리기 쉽습니다.
충돌이 빈번한 환경(High Contention)에서는 낙관적 락의 재시도 비용보다, 비관적 락으로 줄을 세워(Serialization) 처리하는 것이 오히려 전체적인 처리량과 안정성 면에서 낫습니다.

### 요약
> **"속도보다는 정확성(Consistency)과 신뢰성(Reliability)이 중요한 숙소 예약 도메인의 특성상, 데이터 정합성을 가장 확실하게 보장하는 비관적 락을 선택했습니다."**
